<img src = "https://user-images.githubusercontent.com/87309905/208438057-d3c55319-dfb8-4c6f-a519-4def533414c8.png" width/>

> # ë¶„ì„ì„ ìœ„í•œ ë ˆì‹œí”¼ ì¶”ì²œ ì„œë¹„ìŠ¤
> >#### ì§„í–‰ ê¸°ê°„ : 2022/11/04 -> 2022/12/17
> > #### ë°œí‘œ : 2022/12/17
> > #### Data_Link :
> > #### Notion : 
> > > ë‚´ìš©
> > > ì „ì²´ ì¼ì •

```markdown
1ì¸ ê°€êµ¬ê°€ ì¦ê°€í•˜ëŠ” ì‹œëŒ€ì— ì½”ë¡œë‚˜ë¡œ ì¸í•˜ì—¬ ë°°ë‹¬ì´ ì¦ê°€í•˜ê³  ê·¸ì— ë”°ë¥¸ ë°°ë‹¬ë¹„ì— ë¶€ë‹´ì„ ë§ì´ ëŠë‚ë‹ˆë‹¤.
ì´ëŸ¬í•œ ë¶€ë‹´ì„ ì¤„ì´ê³ ì ë°ì´í„° ë¶„ì„ì— ë”°ë¥¸ ë ˆì‹œí”¼ ì¶”ì²œ í”„ë¡œê·¸ë¨ì„ ì‹œì‘í•˜ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.
ì‚¬ìš©ìì˜ ì„±ë³„, ì—°ë ¹ëŒ€, ì¬ë£Œ, ìš”ë¦¬ ë‚œì´ë„, ì¡°ë¦¬ ì‹œê°„ ë“± ë‹¤ì–‘í•œ ì¡°ê±´ì„ ê³ ë ¤í•˜ì—¬ 1ì¸ ê°€êµ¬ë¥¼ ìœ„í•œ ë ˆì‹œí”¼ ì¶”ì²œí•˜ëŠ” í”„ë¡œê·¸ë¨ ì…ë‹ˆë‹¤.
ì´ë¥¼ í†µí•˜ì—¬ ì‹ë¹„ì— ëŒ€í•œ ë¶€ë‹´ì„ ì¤„ì—¬ì£¼ê³  ì§ì ‘ ìš”ë¦¬ë¥¼ ê°„í‰í•˜ê²Œ í•  ìˆ˜ ìˆë„ë¡ ë„ìŒì„ ì£¼ê³ ì í•©ë‹ˆë‹¤.
```
- ì‚¬ìš© ë°ì´í„°
  - ë ˆì‹œí”¼ ë°ì´í„° : ë ˆì‹œí”¼ëª…, ì¡°ë¦¬ì‹œê°„, ìš”ë¦¬ ì¢…ë¥˜, ì¬ë£Œ, ìš”ë¦¬ ë‚œì´ë„
  - ì´ë¯¸ì§€ ë°ì´í„° : ì¬ë£Œì— í•´ë‹¹í•˜ëŠ” ì´ë¯¸ì§€
  - ë ˆì‹œí”¼ ê²€ìƒ‰ëŸ‰ ë°ì´í„° : ë ˆì‹œí”¼ ëª…ì— í•´ë‹¹í•˜ëŠ” ê²€ìƒ‰ëŸ‰(í‚¤ì›Œë“œ ì‚¬ìš´ë“œ)
  - ì„±ë³„, ì—°ë ¹ë³„ ê²€ìƒ‰ëŸ‰ ë°ì´í„° : ë ˆì‹œí”¼ì— í•´ë‹¹í•˜ëŠ” ì„±ë³„, ì—°ë ¹ë³„ ê²€ìƒ‰ëŸ‰(ë„¤ì´í„° íŠ¸ë Œë“œ)
  - ê¸°ìƒì²­ ë°ì´í„° : ì˜¨ë„, ìŠµë„, ê°•ìˆ˜ëŸ‰, ìš´ëŸ‰

## ğŸ’»Â í”„ë¡œì íŠ¸ ì§„í–‰ (ì´ë¯¸ì§€ ì¸ì‹ and ë°ì´í„° ë¶„ì„)

### I. ì´ë¯¸ì§€ ì¸ì‹  
> 1. ë°ì´í„° ìˆ˜ì§‘
> https://kadx.co.kr/product/detail/0c5ec800-4fc2-11eb-8b6e-e776ccea3964
> KADX ë†ì‹í’ˆ ë¹…ë°ì´í„° ê±°ë˜ì†Œì— ìˆëŠ” ë§Œê°œì˜ ë ˆì‹œí”¼ ë°ì´í„°ë¥¼ í™œìš©

> 2. ë°ì´í„° ì „ì²˜ë¦¬ 
>   
> I. ë ˆì‹œí”¼ ë°ì´í„° ì¤‘ ì¬ë£Œ ë°ì´í„°ë¥¼ ì¶”ì¶œ  
> II. ì¤‘ë³µ ì œê±° í›„ ë¦¬ìŠ¤íŠ¸ë¡œ ì¶”ì¶œ  

> 3. ì´ë¯¸ì§€ ë°ì´í„° ìˆ˜ì§‘  
>  
> I. ì¬ë£Œì— í•´ë‹¹í•˜ëŠ” ì´ë¯¸ì§€ë¥¼ ë„¤ì´ë²„ & êµ¬ê¸€ì„ í†µí•˜ì—¬ ì¬ë£Œë‹¹ 100ê°œì”© ì¶”ì¶œ (ì…€ë ˆë‹ˆì›€ í¬ë¡¤ë§ ì‚¬ìš©)  
> II. ë¶ˆí•„ìš”í•œ ë°°ê²½ì´ë‚˜ ì‚¬ë¬¼ë“¤ì´ í¬í•¨ëœ ì´ë¯¸ì§€ ìœ¡ì•ˆìœ¼ë¡œ ì œê±°  
> III. ì´ë¯¸ì§€ì— í•´ë‹¹í•˜ëŠ” ë¼ë²¨ë§ ì‘ì—…ì„ ì‹œí–‰  
> IV. Colabìœ¼ë¡œ ì´ë¯¸ì§€ ì¸ì‹ ì‹¤í–‰  
> 
> <table>
>   <tr>
>     <td>
>       <img src = "https://user-images.githubusercontent.com/87309905/209649054-39b84715-78a5-439f-bf6a-ee46e850958b.png">  
>       epochì— ë”°ë¥¸ train, val ë°ì´í„° ì…‹ì˜ accuracy
>     </td>
>     <td>
>       <img src = "https://user-images.githubusercontent.com/87309905/209649223-6a6aad8a-edf8-4833-9edb-95dc9326e3ad.png">
>       epochì— ë”°ë¥¸ train, val ë°ì´í„°ì…‹ì˜ loss
>     </td>
>   </tr>
> </table>


```
# ...
# Epoch 146/300
# 100/100 [==============================] - 6s 63ms/step - loss: 0.5831 - acc: 0.8233 - val_loss: 0.9350 - val_acc: 0.7207
# Epoch 147/300
# 100/100 [==============================] - 6s 62ms/step - loss: 0.5959 - acc: 0.8100 - val_loss: 0.9028 - val_acc: 0.7307
# Epoch 148/300
# 100/100 [==============================] - 6s 62ms/step - loss: 0.6300 - acc: 0.8053 - val_loss: 0.8664 - val_acc: 0.7260`

# ëª¨ë¸ í‰ê°€
print("-- Evaluate --")
scores = model.evaluate(test_generator)
print("%s: %.2f%%" %(model.metrics_names[1], scores[1]*100))
# acc: 73.29%
```

> ê²°ê³¼ëŠ” ì•½ 73%ì˜ ì •í™•ë„ë¥¼ ë³´ì˜€ìŠµë‹ˆë‹¤.  
> ì •í™•ë„ë¥¼ ë†’ì´ê¸° ìœ„í•˜ì—¬ ëª¨ë¸ì„ ìˆ˜ì • í•˜ì˜€ìŠµë‹ˆë‹¤.  
> 
> YOLOv4 ì»¤ìŠ¤í…€ í•™ìŠµì„ í†µí•˜ì—¬ ì§„í–‰í•˜ì˜€ì§€ë§Œ Colabì—ì„œ ì œê³µí•˜ëŠ” GPUë¥¼ ì´ˆê³¼í•˜ì—¬  
> YOLOv4 -> YOLOv4_tinyë¥¼ ì‚¬ìš©  
![Untitled (2)](https://user-images.githubusercontent.com/87309905/209650438-9b8115da-2808-40b9-8bd3-41a145bd90ad.png)
> YOLOv4_tiny í•™ìŠµ ê²°ê³¼
> - í•™ìŠµ ê²°ê³¼ ëŒ€ë¶€ë¶„ì˜ ì¬ë£Œë¥¼ ì˜ ì¸ì‹ í•˜ì˜€ìŠµë‹ˆë‹¤.
> - ì´ ëª¨ë¸ì„ ì¬ë£Œ ì´ë¯¸ì§€ ì¸ì‹ ëª¨ë¸ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.

### II) ë°ì´í„° ë¶„ì„
> I. ë°ì´í„° ìˆ˜ì§‘  
>   
> https://kadx.co.kr/product/detail/0c5ec800-4fc2-11eb-8b6e-e776ccea3964
> KADX ë†ì‹í’ˆ ë¹…ë°ì´í„° ê±°ë˜ì†Œì— ìˆëŠ” ë§Œê°œì˜ ë ˆì‹œí”¼ ë°ì´í„°ë¥¼ í™œìš©  
>   
> https://data.kma.go.kr/data/grnd/selectAsosRltmList.do?pgmNo=36  
> ê¸°ìƒì²­ì— ìˆëŠ” ê¸°ì˜¨, ìŠµë„, ê°•ìˆ˜ëŸ‰, ìš´ëŸ‰ ë°ì´í„° í™œìš©  
> 
> https://keywordsound.com/  
> í‚¤ì›Œë“œ ì‚¬ìš´ë“œë¥¼ í†µí•˜ì—¬ ê²€ìƒ‰ëŸ‰ ë°ì´í„° ìˆ˜ì§‘. 
> > ê³¼ë„í•˜ê²Œ í¬ë¡¤ë§ì„ í•˜ì—¬ ì„œë²„ë¥¼ ë§ˆë¹„ ì‹œì¼°ìŠµë‹ˆë‹¤. ê°œì¸ì ìœ¼ë¡œ ì—°ë½ì„ ë“œë ¤ ì‚¬ê³¼ë¥¼ ë“œë ¸ê³  ì¢‹ê²Œ ë§ˆë¬´ë¦¬ ë˜ì—ˆìŠµë‹ˆë‹¤.
> > í¬ë¡¤ë§ì€ í•­ìƒ ì‹ ì¤‘í•˜ê³  ì¡°ì‹¬íˆ í•´ì•¼ í•˜ëŠ” ê²ƒì„ ë°°ì› ìŠµë‹ˆë‹¤.
> > 
> ><img width="669" alt="á„‰á…³á„á…³á„…á…µá†«á„‰á…£á†º 2022-12-24 á„‹á…©á„’á…® 8 51 31" src="https://user-images.githubusercontent.com/87309905/209650976-bf31381b-e111-48f2-9827-b1a28c8a6e39.png">
> https://datalab.naver.com/keyword/trendSearch.naver  
> ë„¤ì´ë²„ íŠ¸ë Œë“œë¥¼ ì´ìš©í•˜ì—¬ ì„±ë³„, ì—°ë ¹ë³„ ë°ì´í„°ì˜ ë¹„ìœ¨ ìˆ˜ì§‘  

> II. ë°ì´í„° ì „ì²˜ë¦¬  
>  
> ê¸°ì¤€ : ë‚ ì§œ 2021ë…„ 1/1 ~ 12/31  
> ë§Œê°œì˜ ë ˆì‹œí”¼ : ë ˆì‹œí”¼ ëª…  
> í‚¤ì›Œë“œ ì‚¬ìš´ë“œ : ë ˆì‹œí”¼ëª…ì— í•´ë‹¹í•˜ëŠ” ê²€ìƒ‰ëŸ‰  
> í‚¤ì›Œë“œ ì‚¬ìš´ë“œ + ë„¤ì´ë²„ íŠ¸ëœë“œ :  
> -> max(ë ˆì‹œí”¼ëª…ì— í•´ë‹¹í•˜ëŠ” ê²€ìƒ‰ëŸ‰) * ë„¤ì´ë²„ íŠ¸ëœë“œ ë¹„ìœ¨(ì„±ë³„, ì—°ë ¹ ìƒê°í•´ì•¼í•¨)  
> ê¸°ìƒì²­ ë°ì´í„° : ê¸°ì˜¨, ìŠµë„, ê°•ìˆ˜ëŸ‰, ìš´ëŸ‰  
>  
>  ëª¨ë“  ë°ì´í„°ë¥¼ ë‚ ì§œë³„ë¡œ ì •ë¦¬ë¥¼ í•˜ì—¬ í•˜ë‚˜ì˜ ë°ì´í„°ë¡œ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤.  

> III. ë°ì´í„° ë¶„ì„   
> ë‚ ì”¨, ìš”ì¼, ê³„ì ˆ ë“± ì •ë³´ì™€ ì‚¬ìš©ìê°€ ì…ë ¥í•˜ëŠ” ì¬ë£Œ, ë‚˜ì´, ì„±ë³„ì— ë”°ë¼ ë§Œë“¤ ìˆ˜ ìˆëŠ” ìš”ë¦¬ì˜ ë ˆì‹œí”¼ ì¤‘, ê²€ìƒ‰ëŸ‰ì´ ë§ì„ ê²ƒ ê°™ì€ ë ˆì‹œí”¼ë¥¼ ì˜ˆì¸¡í•˜ê¸° ìœ„í•œ ëª¨  ë¸ì„ ì–»ê³ ì í•˜ì˜€ìŠµë‹ˆë‹¤.  
>   
> - ë°ì´í„° ë¶„ì„ì„ í•  ë•Œ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ì¤„ì´ê¸° ìœ„í•˜ì—¬ DataFrameì˜ DataTypeì„ ë°”ê¾¸ì–´ ì£¼ì—ˆìŠµë‹ˆë‹¤. ë•ë¶„ì— ë©”ëª¨ë¦¬ errorì—†ì´ í•™ìŠµ ì§„í–‰
> ```python
>  def reduce_mem_usage(df):
>    # start_mem = df.memory_usage().sum() / 1024**2
>    # print('Memory usage of dataframe is {:.2f} MB'.format(start_mem))
>
>    for col in df.columns:
>        col_type = df[col].dtype
>
>        if col_type != object:
>            c_min = df[col].min()
>            c_max = df[col].max()
>            if str(col_type)[:3] == 'int':
>                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:
>                    df[col] = df[col].astype(np.int8)
>                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:
>                    df[col] = df[col].astype(np.int16)
>                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:
>                    df[col] = df[col].astype(np.int32)
>                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:
>                    df[col] = df[col].astype(np.int64)
>            else:
>                if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:
>                    df[col] = df[col].astype(np.float16)
>                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:
>                    df[col] = df[col].astype(np.float32)
>                else:
>                    df[col] = df[col].astype(np.float64)
>
>    return df
> ```
> > - ìˆ˜ì§‘í•œ ë°ì´í„°ë¥¼ Ensembleí•™ìŠµ ì¤‘ LightGBMì„ ì‚¬ìš©
> >   
> > LightGBM
> > ```python  
> > from lightgbm import LGBMRegressor
> >  
> > lgbm_t = LGBMRegressor(random_state=1, learning_rate=0.01, n_estimators=2000, colsample_bytree=0.9, subsample=0.7, max_depth=5)
> >  
> > lgbm_t.fit(x_train, y_train). 
> > lgbm_t_pred = lgbm_t.predict(x_test)
> > 
> > print('LGBMRegressor')
> > print('MAE:', mean_absolute_error(y_test, lgbm_t_pred)) # (í‰ê·  ì ˆëŒ€ ì˜¤ì°¨) ì˜ˆì¸¡ê°’ê³¼ ì‹¤ì œê°’ì˜ ì°¨ì´ì˜ ì ˆëŒ€ê°’ì— ëŒ€í•œ í‰ê· 
> > print('MSE:', mean_squared_error(y_test, lgbm_t_pred)) # (í‰ê·  ì œê³± ì˜¤ì°¨) ì˜ˆì¸¡ê°’ê³¼ ì‹¤ì œê°’ì˜ ì°¨ì´ì˜ ì œê³±ì— ëŒ€í•œ í‰ê· 
> > print('RMSE:', np.sqrt(mean_squared_error(y_test, lgbm_t_pred))) # (í‰ê·  ì œê³±ê·¼ ì˜¤ì°¨) ì˜ˆì¸¡ê°’ê³¼ ì‹¤ì œê°’ì˜ ì°¨ì´ì˜ ì œê³±ì— ëŒ€í•œ í‰ê· ì˜ ì œê³±ê·¼
> > print('R2:', r2_score(y_test, lgbm_t_pred)) # (ê²°ì • ê³„ìˆ˜) 1ì— ê°€ê¹Œìš¸ìˆ˜ë¡ ì˜ˆì¸¡ê°’ê³¼ ì‹¤ì œê°’ì´ ê°€ê¹ë‹¤ëŠ” ì˜ë¯¸
> >  
> > # ì˜ˆì¸¡ê°’ê³¼ ì‹¤ì œê°’ ë¹„êµ csv íŒŒì¼ë¡œ ì €ì¥
> > df2 = pd.DataFrame({'Actual': y_test, 'Predicted': lgbm_t_pred})
> > df2.to_csv(os.path.join(path, 'result_lgb.csv'), index=True)
> > 
> > # ëª¨ë¸ ì €ì¥
> > import pickle
> > 
> > with open(os.path.join(path, 'lgbm_t.pkl'), 'wb') as f:
> >     pickle.dump(lgbm_t, f)
> >       
> > # # ëª¨ë¸ ë¶ˆëŸ¬ì˜¤ê¸°
> > # with open(os.path.join(path, 'lgbm_t.pkl'), 'rb') as f:
> > #     lgbm_t = pickle.load(f)
> > 
>  
> > GridSearchCVë¥¼ í†µí•˜ì—¬ ìµœì ì˜ Parameterë¥¼ ì°¾ì•„, ì°¾ì€ ê°’ìœ¼ë¡œ í•™ìŠµì„ ì§„í–‰
> > ```python
> > # ligthgbm ìµœì ì˜ parameter ì°¾ê¸°
> > from sklearn.model_selection import GridSearchCV
> > 
> > lgbm = LGBMRegressor(random_state=1)
> >
> > params = {
> >     'max_depth': [15, 18, 19, 21, 23],
> >     'num_leaves': [50, 80, 100, 120, 150],
> >     'min_data_in_leaf': [100],
> >     'learning_rate': [0.01, 0.05, 0.1, 0.15, 0.2],
> >     'colsample_bytree': [0.5, 0.7, 0.9, 1],
> >     'subsample': [0.5, 0.7, 0.9, 1]
> > }
> > 
> > grid_cv = GridSearchCV(lgbm, param_grid=params, cv=5, n_jobs=-1)
> > grid_cv.fit(x_train, y_train, verbose=1, eval_metric=['rmse', 'mae'], eval_set=[(x_train, y_train), (x_test, y_test)], early_stopping_rounds=100)
> > 
> > print('ìµœì ì˜ íŒŒë¼ë¯¸í„°:', grid_cv.best_params_)
> > print('ìµœê³  ì˜ˆì¸¡ ì •í™•ë„: {0:.4f}'.format(grid_cv.best_score_))
> > ```
> > 
> > ```python
> >lgbm_t = LGBMRegressor(random_state=1, n_estimators=2000, max_depth=15, num_leaves=150, min_data_in_leaf=100, learning_rate=0.2,
> >                        colsample_bytree=1, subsample=0.7)
> > ```
> > Parameterë¥¼ íŠœë‹í•œ ê²°ê³¼ 2%ì •ë„ì˜ ë” ë†’ì€ ì˜ˆì¸¡ ì •í™•ë„ë¥¼ ë³´ì˜€ìŠµë‹ˆë‹¤.
> > 
> > <table> 
> >   <tr>
> >     <td>
> >       <img src="https://user-images.githubusercontent.com/87309905/209656040-9b1b55d3-1793-4b9b-9b30-da406b38a34f.png"> ParameteríŠœë‹ ì „ ê¸°ë³¸ê°’ìœ¼ë¡œ í•™ìŠµ
> >     </td>
> >     <td>
> >       <img src="https://user-images.githubusercontent.com/87309905/209656432-e0b83533-399b-4187-b1f7-d3584fc5d6ad.png"> Parameter íŠœë‹ í›„ ì–»ì€ ê²°ê³¼ë¡œ í•™ìŠµ
> >     </td>
> >   </tr>
> > </table>
> > - ê²°ê³¼ì ìœ¼ë¡œ ì™„ë²½íˆ ì¼ì¹˜í•˜ì§€ëŠ” ì•Šìœ¼ë‚˜, Predictedê°’ì´ Actualê°’ê³¼ ë¹„ìŠ·í•œ íë¦„ì„ ê°€ì§„ë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
> > - ì¦‰, ê²€ìƒ‰ëŸ‰ì„ ì •í™•íˆ ì˜ˆì¸¡ì„ í•  ìˆ˜ ì—†ìœ¼ë‚˜ ìƒëŒ€ì ì¸ ë³€í™”ë¥¼ ì—ì¸¡í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
> > - ë” ë§ì€ featureì™€ ë°ì´í„°ë“¤ì´ ìˆì—ˆë”ë¼ë©´ ë”ìš± ì •í™•í•œ ì˜ˆì¸¡ê°’ì„ ì–»ì„ ìˆ˜ ìˆì§€ ì•Šì„ê¹Œë¼ëŠ” ì•„ì‰¬ì›€ì´ ë‚¨ì•˜ìŠµë‹ˆë‹¤.  
> >     
> > ë¶„ì„í•œ ëª¨ë¸ì„ ì €ì¥. 
> > ```python
> > import pickle
> > with open(os.path.join(path, 'lgbm_t.pkl'), 'wb') as f:
> >    pickle.dump(lgbm_t.fit(x_train, y_train), f)
> > ```

> ì´ë¯¸ì§€ ì¸ì‹ ëª¨ë¸ê³¼ ë¶„ì„ ëª¨ë¸ì„ í™œìš©í•œ ë ˆì‹œí”¼ ì¶”ì²œ  
>  
> - ì¬ë£Œ ì´ë¯¸ì§€ë¥¼ ì¸ì‹í•˜ì—¬ ì¬ë£Œë¥¼ íŒŒë³„í•˜ì—¬ ë§Œë“¤ ìˆ˜ ìˆëŠ” ë ˆì‹œí”¼ ë¨¼ì € ì œê³µ  
> - ì œê³µëœ ë ˆì‹œí”¼ ì¤‘ ì„±ë³„, ë‚˜ì´, ë‚ ì”¨ ë“± ë‹¤ì–‘í•œ ì¡°ê±´ì„ ì¡°í•©ì—¬ ìµœì¢…ì ìœ¼ë¡œ ê²€ìƒ‰ëŸ‰ì´ ê°€ì¥ ë†’ì€, ì¦‰, ì‚¬ëŒë“¤ì´ ê°€ì¥ ì¦ê²¨ ë¨¹ëŠ” ë ˆì‹œí”¼ë¥¼ í•™ìŠµ ëª¨ë¸ì„ í†µí•˜ì—¬ ì•Œë ¤ì¤ë‹ˆë‹¤.  
> ```python
> def yolo(frame, size, score_threshold, nms_threshold):
>     """YOLO ì‹œì‘"""
>     # YOLO ë„¤íŠ¸ì›Œí¬ ë¶ˆëŸ¬ì˜¤ê¸°
>     net = cv2.dnn.readNet("weights íŒŒì¼ ê²½ë¡œ",
>                           "cfg íŒŒì¼ ê²½ë¡œ")
>     layer_names = net.getLayerNames()
>     output_layers = [layer_names[i - 1] for i in net.getUnconnectedOutLayers()]
> 
>     # í´ë˜ìŠ¤ì˜ ê°¯ìˆ˜ë§Œí¼ ëœë¤ RGB ë°°ì—´ì„ ìƒì„±
>     colors = np.random.uniform(0, 255, size=(len(classes), 3))
>
>     # ì´ë¯¸ì§€ì˜ ë†’ì´, ë„ˆë¹„, ì±„ë„ ë°›ì•„ì˜¤ê¸°
>     height, width, channels = frame.shape
> 
>     # ë„¤íŠ¸ì›Œí¬ì— ë„£ê¸° ìœ„í•œ ì „ì²˜ë¦¬
>     blob = cv2.dnn.blobFromImage(frame, 0.00392, (size, size), (0, 0, 0), True, crop=False)
> 
>     # ì „ì²˜ë¦¬ëœ blob ë„¤íŠ¸ì›Œí¬ì— ì…ë ¥
>     net.setInput(blob)
> 
>     # ê²°ê³¼ ë°›ì•„ì˜¤ê¸°
>     outs = net.forward(output_layers)
> 
>     # ê°ê°ì˜ ë°ì´í„°ë¥¼ ì €ì¥í•  ë¹ˆ ë¦¬ìŠ¤íŠ¸
>     class_ids = []
>     confidences = []
>     boxes = []
> 
>     for out in outs:
>         for detection in out:
>             scores = detection[5:]
>             class_id = np.argmax(scores)
>             confidence = scores[class_id]
> 
>             if confidence > 0.1:
>                 # íƒì§€ëœ ê°ì²´ì˜ ë„ˆë¹„, ë†’ì´ ë° ì¤‘ì•™ ì¢Œí‘œê°’ ì°¾ê¸°
>                 center_x = int(detection[0] * width)
>                 center_y = int(detection[1] * height)
>                 w = int(detection[2] * width)
>                 h = int(detection[3] * height)
> 
>                 # ê°ì²´ì˜ ì‚¬ê°í˜• í…Œë‘ë¦¬ ì¤‘ ì¢Œìƒë‹¨ ì¢Œí‘œê°’ ì°¾ê¸°
>                 x = int(center_x - w / 2)
>                 y = int(center_y - h / 2)
> 
>                 boxes.append([x, y, w, h])
>                 confidences.append(float(confidence))
>                 class_ids.append(class_id)
> 
>     # í›„ë³´ ë°•ìŠ¤(x, y, width, height)ì™€ confidence(ìƒìê°€ ë¬¼ì²´ì¼ í™•ë¥ ) ì¶œë ¥
>     print(f"boxes: {boxes}")
>     print(f"confidences: {confidences}")
> 
>     # Non Maximum Suppression (ê²¹ì³ìˆëŠ” ë°•ìŠ¤ ì¤‘ confidence ê°€ ê°€ì¥ ë†’ì€ ë°•ìŠ¤ë¥¼ ì„ íƒ)
>     indexes = cv2.dnn.NMSBoxes(boxes, confidences, score_threshold=score_threshold, nms_threshold=nms_threshold)
> 
>     # í›„ë³´ ë°•ìŠ¤ ì¤‘ ì„ íƒëœ ë°•ìŠ¤ì˜ ì¸ë±ìŠ¤ ì¶œë ¥
>     print(f"indexes: ", end='')
>     for index in indexes:
>         print(index, end=' ')
>     print("\n\n============================== classes ==============================")
> 
>     for i in range(len(boxes)):
>         if i in indexes:
>             x, y, w, h = boxes[i]
>             class_name = classes[class_ids[i]]
>             label = f"{class_name} {confidences[i]:.2f}"
>             color = colors[class_ids[i]]
> 
>             # ì‚¬ê°í˜• í…Œë‘ë¦¬ ê·¸ë¦¬ê¸° ë° í…ìŠ¤íŠ¸ ì“°ê¸°
>             cv2.rectangle(frame, (x, y), (x + w, y + h), color, 2)
>             cv2.rectangle(frame, (x - 1, y), (x + len(class_name) * 13 + 65, y - 25), color, -1)
>             cv2.putText(frame, label, (x, y - 8), cv2.FONT_HERSHEY_COMPLEX_SMALL, 1, (0, 0, 0), 2)
> 
>             # íƒì§€ëœ ê°ì²´ì˜ ì •ë³´ ì¶œë ¥
>             print(f"[{class_name}({i})] conf: {confidences[i]} / x: {x} / y: {y} / width: {w} / height: {h}")
>             globals()['ingre_list'].append(class_name)
> 
>     return frame
> ```
> -> YOLOv4-tinyë¡œ í•™ìŠµëœ ëª¨ë¸ë¡œ ì´ë¯¸ì§€ë¥¼ ì¸ì‹í•˜ê³  ì¸ì‹ëœ ì´ë¯¸ì§€ì™€ ì¸ì‹ëœ ì¬ë£Œì˜ ê²°ê³¼ë¥¼ ì¶œë ¥
> 
> ```python
> # lgbm_t.pkl íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸°
> with open('í•™ìŠµëœ lgbm pickle íŒŒì¼', 'rb') as f:
>     lgbm_t = pickle.load(f)
> 
> # print(lgbm_t)
> 
> # ì„ì‹œë¡œ ë„£ì€ ì¡°ê±´
> Gender = 1 # ë‚¨ì
> Age = 20 # 20ëŒ€
> Temperature = 20.0 # ì˜¨ë„
> Precipitation = 0.0 # ê°•ìˆ˜ëŸ‰
> Humidity = 0.0 # ìŠµë„
> Cloud = 0.0 # êµ¬ë¦„
> Month = 12 # 12ì›”
> Season = 4 # ê²¨ìš¸
> Weekday = 5 # í† ìš”ì¼
> 
> # print(df2)
>
> model = lgbm_t
> 
> df2 = df2['CKG_NM']
> df2 = df2.values.reshape(-1, 1)
> # print(df2)
> 
> df3 = pd.DataFrame(columns=['RCP_NM', 'score'])
> 
> for i in range(len(df2)):
>     input_data = [df2[i][0], Gender, Age, Temperature, Precipitation, Humidity, Cloud, Month, Season, Weekday]
>     # print(input_data)
>     # print(model.predict([input_data]))
>     # df3ì— df2ì˜ CKG_NMê³¼ model.predict([input_data])ì˜ ì˜ˆì¸¡ê°’ì„ ì „ë¶€ ì €ì¥
>     df3 = df3.append({'RCP_NM': df2[i][0], 'score': model.predict([input_data])}, ignore_index=True)
> 
> # df3ì˜ RCP_NMì´ df1ì˜ CKG_NM2ê°€ ê°™ìœ¼ë©´ CKG_NMì„ RCP_NMìœ¼ë¡œ ì €ì¥
> df3['RCP_NM'] = df3['RCP_NM'].map(df1.set_index('CKG_NM2')['CKG_NM'])
> # df3ì˜ scoreë¥¼ ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ ì •ë ¬
> df3 = df3.sort_values(by='score', ascending=False)
> print(df3.head())
> ```
> > LightGBMìœ¼ë¡œ í•™ìŠµëœ ëª¨ë¸ì„ ì‚¬ìš©í•˜ì—¬ ì¸ì‹ëœ ì¬ë£Œì™€, ë¯¸ë¦¬ ì…ë ¥ëœ ì„±ë³„, ë‚ ì”¨ ê³„ì ˆ ë“± ë‹¤ì–‘í•œ ì¡°ê±´ì„ ì¡°í•©í•˜ì—¬ ìµœì¢…ì ìœ¼ë¡œ ê²€ìƒ‰ëŸ‰ì´ ë†’ì€ ë ˆì‹œí”¼ë¥¼ ì˜ˆì¸¡í•˜ì—¬ ì¶”ì²œ
> ì˜ˆì¸¡ ê²°ê³¼
> ì¡°ê±´ : 12ì›”, ê²¨ìš¸, í† ìš”ì¼, ê°•ìˆ˜X, êµ¬ë¦„X, ìŠµë„X, 20ëŒ€, ë‚¨ì
> ì¬ë£Œ
> ![Untitled (5)](https://user-images.githubusercontent.com/87309905/209658913-5075c3b8-32d3-4126-8864-cef879af47dc.png)
> ë³µìˆ­ì•„(ê³„ë€), ëŒ€íŒŒ, ë§ˆëŠ˜, ìŠ¤íŒ¸
>  
> > ê²°ê³¼  
> > RCP_NM                score
> > 292 ë–¡ë³¶ì´ [135.63899760197575] 
> > 291 ë–¡ê¼¬ì¹˜ [135.63899760197575] 
> > 290 ë–¡ê°ˆë¹„ê¼¬ì¹˜ [135.63899760197575] 
> > 289 ë–¡ê°ˆë¹„êµ¬ì´ [135.63899760197575] 
> > 472 ìƒ¤ë¸Œìƒ¤ë¸Œ [132.77751317420473]
>  
> Scoreê°€ ë†’ì€ ìˆœìœ¼ë¡œ 1ìœ„ì—ì„œ 5ìœ„ì…ë‹ˆë‹¤.  
> ë–¡ë³¶ì´ê°€ ê°€ì¥ ë†’ë‹¤ê³  ì˜ˆì¸¡. 
> 
> -  ê³„ë€ì´ ì™œ ë³µìˆ­ì•„ë¡œ ì¸ì‹ë˜ì—ˆëŠ”ì§€, ë‹¤ì‹œ ì‚´í´ë´ì•¼ í• ê²ƒ ê°™ìŠµë‹ˆë‹¤.  
> - ê·¸ ì´ì™¸ì—ëŠ” ì˜ ì¸ì‹ë˜ëŠ” ê²ƒìœ¼ë¡œë³´ì•„, YOLOv4-tinyë¥¼ ì˜ ì‚¬ìš©í•œê²ƒ ê°™ìŠµë‹ˆë‹¤.  

> IV. ì›¹í˜ì´ì§€ êµ¬í˜„
>
> ì´ë¯¸ì§€ ì¸ì‹ì„ êµ¬í˜„í•˜ì˜€ìœ¼ë‚˜ ì›¹í˜ì´ì§€ì— ì ìš©ì„ ì‹œí‚¤ì§€ëŠ” ëª»í•˜ì—¬ ì•„ì‰¬ì›€ì´ ìˆì—ˆìŠµë‹ˆë‹¤.

> IV. ì–´í”Œë¦¬ì¼€ì´ì…˜ í™”ë©´ êµ¬ì„±
>

## ë°°ìš´ì 
- í¬ë¡¤ë§ì€ ì‹ ì¤‘í•˜ê³  ì¡°ì‹¬íˆ ë‹¤ë¤„ì•¼ í•˜ëŠ” ê²ƒì„ ë°°ì› ìŠµë‹ˆë‹¤.
'í‚¤ì›Œë“œ ì‚¬ìš´ë“œ'ë¼ëŠ” í™ˆí˜ì´ì§€ë¥¼ Seleniumìœ¼ë¡œ í¬ë¡¤ë§ì„ í•˜ë‹¤ê°€ ë§ì€ íŠ¸ë˜í”½ì´ ëª°ë ¤ ì‚¬ì´íŠ¸ê°€ ë§ˆë¹„ë˜ì—ˆìŠµë‹ˆë‹¤.
ì´í›„ ì‚¬ì´íŠ¸ ê°œë°œìë‹˜ì—ê²Œ í”¼í•´ë¥¼ ì…í˜€, ê°œì¸ì ìœ¼ë¡œ ì—°ë½ë“œë ¤ ì‚¬ê³¼ë“œë ¸ìŠµë‹ˆë‹¤.
